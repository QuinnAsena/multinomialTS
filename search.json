[{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"multinomialTS Vignette","text":"One primary goals model able test multiple hypotheses data lend statistical support different hypotheses. example environmental drivers strongest effects taxa? , interactions among taxa abiotic variables driving change system? state-space approach allows us estimate coefficients taxa interactions driver-taxa relationships, don’t get methods ordination cluster analysis. recommend method complimentary methods, advantages. vignette take us : Choosing binning resolution mnTS() Finding initial conditions mnGLMM() Fitting mnTS() without species interactions assess resulting models","code":""},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"this-vignette","dir":"Articles","previous_headings":"","what":"This vignette","title":"multinomialTS Vignette","text":"vignette take us : Choosing binning resolution mnTS() Finding initial conditions mnGLMM() Fitting mnTS() without species interactions assess resulting models","code":""},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"fitting-mnts","dir":"Articles","previous_headings":"","what":"Fitting mnTS()","title":"multinomialTS Vignette","text":"vignette work data focal taxa groups already wrangled. second vignette added cover data wrangling, now see state variable (YY) data look like: covariate (XX): moment, keeiping age depth columns tibbles. columns common variable match two tibbles, removed little lates. start chosing resolution model predictions (e.g., predicting ecological process 50 100 year intervals). looks great! bin data around 50-75 years, still data independent bins. Now know roughly bin-width use maximise number observations state variables, apply bin-width state variables covariate data. Ask questions! questions far? Covariates need handled according decisions made around state variables, , state variables binned century-level resolution covariates must match resolution. can finer temporal resolution covariates state variables. dataset, state variables r nrow(story_pollen_wide) observations, covariate r nrow(story_char_wide[story_char_wideage<=max(storypollenwideage <= max(story_pollen_wideage), ]) observations time-span. observations environmental covariates common palaeo-data works well fitting model. Since need apply binning procedure state variables covariate, like join datasets. Charcoal sampled greater depth pollen data, going clip covariate extent state variables join two datasets common variable, age. Now data joined. Note covariate XX (char_acc) observations every cm, whereas pollen sampled less frequent intervals (OK! :smiley:). always lots quick checks like head(), tail(), dim() (many !) make sure catch coding mistakes! looks good, can now bin data appropriate temporal resolution fitting model. Chosing bin-width may take trial error, ’m going bin-width 50 years. now apply bins data. types covariates want average value covariate bin. pollen count data, want sum. underlying multinomial distribution model. Let’s see data look like binned 50 year resolution: looking good, reduced time-intervals run model. data nowr nrow(story_binned rows complete covariate data, containingr nrow(story_binned[(rowSums(story_binned[ ,4:7]) != 0), ]) state variable observations. original number pollen observations r nrow(story_pollen_wide), summed many observations within bins. multinomialTS requires two matrices, site--species matrix YY, covariate matrix XX, leave tibbles behind split data. XX variables may different types (e.g., continuous, categorical…) scaled relative . Ok, now : Chosen temporal resolution model r bin_width year bins Organised data site--species matrix YY r bin_width year bins Binned scaled covariate matrix XX , can fit model. mnTS() function provide estimates biotic interactions (CC matrix), taxa-driver relationships (BB matrix), cross-correlated error (VV matrix). model needs initial starting values parameters begin . get initial starting conditions data running mnGLMM() funcion. mnGLMM() returns estimates BB VV matrices (CC matrix) assumes time gaps data. Tip arguments starting values mnGLMM() mnTS() suffixed .start (e.g., B.start starting values BB matrix). arguments parameters estimated suffixed .fixed (e.g., B.fixed parameters estimated BB matrix). Now, lets set parameters mnGLMM(). need: vector indicates row indices state variable observations: sample_idx integer number covariates (+ 1 mnGLMM()): p integer number state variables: n matrix starting values BB: B.start.glmm matrix BB parameters estimate: B.fixed.glmm matrix VV parameters estimate: V.fixed.glmm Set-remaining parameters: parameters used arguments mnGLMM() function. Check printing console. matrix needs correct dimensions given number taxa number covariates. position elements matrix reflect species /covariates, see later output model. Remember mnGLMM() handle gaps data fits complete XX YY matrices. created variable observation indices (sample_idx), mnGLMM() index matrices variable: e.g., story_pollen_matrix[sample_idx, ]. outputs mnGLMM() can examined summary(glmm_mod) coef(glmm_mod) functions. Now, lets set parameters mnTS(). mTS() needs: row indices : sample_idx number covariates: p number state variables: n BOBO: B0.start.mnTS (intercept) BB: B.start.mnTS (driver-taxa) CC: C.start.mnTS (taxa interactions) VV: V.start.mnTS (cross-correlated error) BOBO: B0.fixed.mnTS BB: B.fixed.mnTS CC: C.fixed.mnTS VV: V.fixed.mnTS using output mnGLMM() starting values matrices B0B0, BB, VV. mnGLMM() provide estimates CC, handle CC little differently input values close zero parameter estimated let mnTS() rest. Remember, mnTS() handle gaps state-variables data covariate matrix. following code, use complete (gaps) YY matrix story_pollen_matrix[sample_idx, ] dimensions: r dim(story_pollen_matrix[sample_idx, ]). full XX matrix: story_char_matrix_scaled dimensions: r dim(story_char_matrix_scaled) fit model twice: - without taxa interactions - without taxa interactions. Without interactions interactions start_time <- Sys.time() mnTS_mod <- mnTS(Y = story_pollen_matrix[sample_idx, ],                  X = story_char_matrix_scaled, Tsample = sample_idx,                  B0.start = B0.start.mnTS, B0.fixed = B0.fixed.mnTS,                  B.start = B.start.mnTS, B.fixed = B.fixed.mnTS,                  C.start = C.start.mnTS, C.fixed = C.fixed.mnTS,                  V.start = V.start.mnTS, V.fixed = V.fixed.mnTS,                  dispersion.fixed = 1, maxit.optim = 1e+6) # maxit.optim max number iterations optimiser complete stopping. # increase maxit.optim model needs lot time fit. end_time <- Sys.time() end_time - start_time saveRDS(mnTS_mod, \"./outputs/mnTS_mod.rds\") coef() summary() functions show model outputs. Let’s check coefficients interaction model: found bootstrapping provides better estimates standard erros (subsequent P-values). boot() function bootstrap model, may take long time. won’t today, strongly recommend bootstrapping final models. summary model provides log likelihood AIC (akaike information criterion). can used comparing models. Today use AIC. AIC penalised number parameters estimated, can better comparing models one parameters estimated (.e., interaction model estimating parameters model without interactions). AIC (log likelihood) values can accessed directly mnTS_mod_int$AIC.","code":"# Load required packages library(ggplot2) library(dplyr) Attaching package: 'dplyr' The following objects are masked from 'package:stats':      filter, lag The following objects are masked from 'package:base':      intersect, setdiff, setequal, union library(tidyr) library(stringr) library(scales) library(RcppArmadillo) library(minqa) library(matrixStats) Attaching package: 'matrixStats' The following object is masked from 'package:dplyr':      count library(numDeriv) library(mvtnorm) library(multinomialTS)  # Read-in the wrangled data  # Read in our X variables data(\"story_char_wide\", package = \"multinomialTS\") Warning in data(\"story_char_wide\", package = \"multinomialTS\"): data set 'story_char_wide' not found # Read in the long data for plotting data(\"story_pollen_wide\", package = \"multinomialTS\") Warning in data(\"story_pollen_wide\", package = \"multinomialTS\"): data set 'story_pollen_wide' not found head(story_pollen_wide) head(story_char_wide) # Time-span of the data divided by the numer of observations max(story_pollen_wide$age) / nrow(story_pollen_wide)  # Age differences between successive observations diff(story_pollen_wide$age)   # The range of the age differences range(diff(story_pollen_wide$age))  # the average of the age differences mean(diff(story_pollen_wide$age))  sd(diff(story_pollen_wide$age)) # Clip covariate data to the extent of the state variables # Join the two by age so that we get a square matrix story_join <- story_char_wide |>   filter(age <= max(story_pollen_wide$age)) |>   left_join(story_pollen_wide)  # Always double check dimensions before/after joining! # dim(story_join) # tail(story_join) head(story_join, n = 10) tail(story_join, n = 10) # This code chunks the data into bins and gives us a grouping variable \"bins\"  bin_width <- 50 bins <- cut(story_join$age,             breaks = seq(from = min(story_join$age),             to = max(story_join$age + bin_width),             by = bin_width), include.lowest = TRUE, labels = FALSE) # The following code  story_binned <- bind_cols(bins = bins, story_join) |>   group_by(bins) |> # Group the data by the bins so that we calculate per time bin   summarise(     age = mean(age, na.rm = T), # the center of the bin     char_acc = mean(char_acc, na.rm = T), # mean charcoal accumulation rate per bin     other = sum(other, na.rm = T), # the sums of the count data     hardwood = sum(hardwood, na.rm = T),     `Fagus grandifolia` = sum(`Fagus grandifolia`, na.rm = T),     Ulmus = sum(Ulmus, na.rm = T),     Quercus = sum(Quercus, na.rm = T)   ) |>   arrange(desc(age)) # Be aware that the gaps in the pollen data are now filled with 0's not NA head(story_binned, n = 10) story_pollen_matrix <- story_binned |>  # Select taxa   select(other, hardwood, Ulmus, `Fagus grandifolia`, Quercus) |>    rename(\"Fagus\" = \"Fagus grandifolia\") |>    as.matrix() # Replacing 0 with NA is not strictly necessary the way we use the data today # But it is a good safety to avoid 0-count data where it zhould be no observation story_pollen_matrix[which(rowSums(story_pollen_matrix) == 0), ] <- NA head(story_pollen_matrix)  story_char_matrix_scaled <- story_binned |> # select covariates   select(char_acc) |>    as.matrix() |>    scale() # Scale covariates head(story_char_matrix_scaled) # set-up sample index sample_idx <- which(rowSums(story_pollen_matrix) != 0) # make sure it works head(story_pollen_matrix[sample_idx, ]) # Set-up parameters p <- ncol(story_char_matrix_scaled) + 1 # Number of independent variables plus intercept n <- ncol(story_pollen_matrix) # number of taxa V.fixed.glmm <- diag(n) diag(V.fixed.glmm) <- NA V.fixed.glmm[1] <- 1 B.fixed.glmm <- matrix(c(rep(0,p),rep(NA, (n - 1) * p)), p, n) # reference taxa [,1] are set to 0 B.start.glmm <- matrix(c(rep(0,p),rep(.01, (n - 1) * p)), p, n) # reference taxa [,1] are set to 0 # fit glmm start_time <- Sys.time() glmm_mod <- mnGLMM(Y = story_pollen_matrix[sample_idx, ],                    X = story_char_matrix_scaled[sample_idx, ,drop = F],                    B.start = B.start.glmm,                    B.fixed = B.fixed.glmm,                    V.fixed = V.fixed.glmm) end_time <- Sys.time() end_time - start_time saveRDS(glmm_mod, \"./outputs/glmm_mod.rds\") glmm_mod <- readRDS(\"./outputs/glmm_mod.rds\") summary(glmm_mod) # B.start etc B0.start.mnTS <- glmm_mod$B[1, , drop = F] B.start.mnTS <- glmm_mod$B[2, , drop = F]  sigma.start.mnTS <- glmm_mod$sigma  V.fixed.mnTS = matrix(NA, n, n) # Covariance matrix of environmental variation in process eq V.fixed.mnTS[1] = 1  V.start.mnTS = V.fixed.mnTS V.start.mnTS <- glmm_mod$V  B.fixed.mnTS <- matrix(NA, p-1, n) B.fixed.mnTS[,1] <- 0 B0.fixed.mnTS = matrix(c(0, rep(NA, n - 1)), nrow = 1, ncol = n)  # Set-up C without interactions C.start.mnTS = .5 * diag(n) C.fixed.mnTS <- C.start.mnTS C.fixed.mnTS[C.fixed.mnTS != 0] <- NA  # Set-up C with interactions between Fagus and Quercus C.start.int.mnTS = .5 * diag(n) C.start.int.mnTS[5, 4] <- .001 C.start.int.mnTS[4, 5] <- .001 C.fixed.int.mnTS <- C.start.int.mnTS C.fixed.int.mnTS[C.fixed.int.mnTS != 0] <- NA start_time <- Sys.time() mnTS_mod <- mnTS(Y = story_pollen_matrix[sample_idx, ],                  X = story_char_matrix_scaled, Tsample = sample_idx,                  B0.start = B0.start.mnTS, B0.fixed = B0.fixed.mnTS,                  B.start = B.start.mnTS, B.fixed = B.fixed.mnTS,                  C.start = C.start.mnTS, C.fixed = C.fixed.mnTS,                  V.start = V.start.mnTS, V.fixed = V.fixed.mnTS,                  dispersion.fixed = 1, maxit.optim = 1e+6) # maxit.optim is the max number of iterations the optimiser will complete before stopping. # increase maxit.optim if the model needs a lot of time to fit. end_time <- Sys.time() end_time - start_time saveRDS(mnTS_mod, \"./outputs/mnTS_mod.rds\") start_time <- Sys.time() mnTS_mod_int <- mnTS(Y = story_pollen_matrix[sample_idx, ],                      X = story_char_matrix_scaled, Tsample = sample_idx,                      B0.start = mnTS_mod$B0, B0.fixed = B0.fixed.mnTS,                      B.start = mnTS_mod$B, B.fixed = B.fixed.mnTS,                      C.start = mnTS_mod$C, C.fixed = C.fixed.int.mnTS,                      V.start = mnTS_mod$V, V.fixed = V.fixed.mnTS,                      dispersion.fixed = 1, maxit.optim = 1e+6) end_time <- Sys.time()  end_time - start_time saveRDS(mnTS_mod_int, \"./outputs/mnTS_mod_int.rds\") mnTS_mod <- readRDS(\"./outputs/mnTS_mod.rds\") mnTS_mod_int <- readRDS(\"./outputs/mnTS_mod_int.rds\") coef(mnTS_mod_int) data.frame(without_interactions = mnTS_mod$AIC,            with_interactions = mnTS_mod_int$AIC)"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"state-variables-y","dir":"Articles","previous_headings":"","what":"State variables YY","title":"multinomialTS Vignette","text":"start chosing resolution model predictions (e.g., predicting ecological process 50 100 year intervals). looks great! bin data around 50-75 years, still data independent bins. Now know roughly bin-width use maximise number observations state variables, apply bin-width state variables covariate data. Ask questions! questions far?","code":"# Time-span of the data divided by the numer of observations max(story_pollen_wide$age) / nrow(story_pollen_wide)  # Age differences between successive observations diff(story_pollen_wide$age)   # The range of the age differences range(diff(story_pollen_wide$age))  # the average of the age differences mean(diff(story_pollen_wide$age))  sd(diff(story_pollen_wide$age))"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"handling-the-covariates-x","dir":"Articles","previous_headings":"","what":"Handling the covariates XX","title":"multinomialTS Vignette","text":"Covariates need handled according decisions made around state variables, , state variables binned century-level resolution covariates must match resolution. can finer temporal resolution covariates state variables. dataset, state variables r nrow(story_pollen_wide) observations, covariate r nrow(story_char_wide[story_char_wideage<=max(storypollenwideage <= max(story_pollen_wideage), ]) observations time-span. observations environmental covariates common palaeo-data works well fitting model. Since need apply binning procedure state variables covariate, like join datasets. Charcoal sampled greater depth pollen data, going clip covariate extent state variables join two datasets common variable, age. Now data joined. Note covariate XX (char_acc) observations every cm, whereas pollen sampled less frequent intervals (OK! :smiley:). always lots quick checks like head(), tail(), dim() (many !) make sure catch coding mistakes! looks good, can now bin data appropriate temporal resolution fitting model. Chosing bin-width may take trial error, ’m going bin-width 50 years. now apply bins data. types covariates want average value covariate bin. pollen count data, want sum. underlying multinomial distribution model. Let’s see data look like binned 50 year resolution: looking good, reduced time-intervals run model. data nowr nrow(story_binned rows complete covariate data, containingr nrow(story_binned[(rowSums(story_binned[ ,4:7]) != 0), ]) state variable observations. original number pollen observations r nrow(story_pollen_wide), summed many observations within bins. multinomialTS requires two matrices, site--species matrix YY, covariate matrix XX, leave tibbles behind split data. XX variables may different types (e.g., continuous, categorical…) scaled relative .","code":"# Clip covariate data to the extent of the state variables # Join the two by age so that we get a square matrix story_join <- story_char_wide |>   filter(age <= max(story_pollen_wide$age)) |>   left_join(story_pollen_wide)  # Always double check dimensions before/after joining! # dim(story_join) # tail(story_join) head(story_join, n = 10) tail(story_join, n = 10) # This code chunks the data into bins and gives us a grouping variable \"bins\"  bin_width <- 50 bins <- cut(story_join$age,             breaks = seq(from = min(story_join$age),             to = max(story_join$age + bin_width),             by = bin_width), include.lowest = TRUE, labels = FALSE) # The following code  story_binned <- bind_cols(bins = bins, story_join) |>   group_by(bins) |> # Group the data by the bins so that we calculate per time bin   summarise(     age = mean(age, na.rm = T), # the center of the bin     char_acc = mean(char_acc, na.rm = T), # mean charcoal accumulation rate per bin     other = sum(other, na.rm = T), # the sums of the count data     hardwood = sum(hardwood, na.rm = T),     `Fagus grandifolia` = sum(`Fagus grandifolia`, na.rm = T),     Ulmus = sum(Ulmus, na.rm = T),     Quercus = sum(Quercus, na.rm = T)   ) |>   arrange(desc(age)) # Be aware that the gaps in the pollen data are now filled with 0's not NA head(story_binned, n = 10) story_pollen_matrix <- story_binned |>  # Select taxa   select(other, hardwood, Ulmus, `Fagus grandifolia`, Quercus) |>    rename(\"Fagus\" = \"Fagus grandifolia\") |>    as.matrix() # Replacing 0 with NA is not strictly necessary the way we use the data today # But it is a good safety to avoid 0-count data where it zhould be no observation story_pollen_matrix[which(rowSums(story_pollen_matrix) == 0), ] <- NA head(story_pollen_matrix)  story_char_matrix_scaled <- story_binned |> # select covariates   select(char_acc) |>    as.matrix() |>    scale() # Scale covariates head(story_char_matrix_scaled)"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"fitting-multinomialts","dir":"Articles","previous_headings":"","what":"Fitting multinomialTS","title":"multinomialTS Vignette","text":"Ok, now : Chosen temporal resolution model r bin_width year bins Organised data site--species matrix YY r bin_width year bins Binned scaled covariate matrix XX , can fit model. mnTS() function provide estimates biotic interactions (CC matrix), taxa-driver relationships (BB matrix), cross-correlated error (VV matrix). model needs initial starting values parameters begin . get initial starting conditions data running mnGLMM() funcion. mnGLMM() returns estimates BB VV matrices (CC matrix) assumes time gaps data. Tip arguments starting values mnGLMM() mnTS() suffixed .start (e.g., B.start starting values BB matrix). arguments parameters estimated suffixed .fixed (e.g., B.fixed parameters estimated BB matrix). Now, lets set parameters mnGLMM(). need: vector indicates row indices state variable observations: sample_idx integer number covariates (+ 1 mnGLMM()): p integer number state variables: n matrix starting values BB: B.start.glmm matrix BB parameters estimate: B.fixed.glmm matrix VV parameters estimate: V.fixed.glmm Set-remaining parameters: parameters used arguments mnGLMM() function. Check printing console. matrix needs correct dimensions given number taxa number covariates. position elements matrix reflect species /covariates, see later output model. Remember mnGLMM() handle gaps data fits complete XX YY matrices. created variable observation indices (sample_idx), mnGLMM() index matrices variable: e.g., story_pollen_matrix[sample_idx, ]. outputs mnGLMM() can examined summary(glmm_mod) coef(glmm_mod) functions. Now, lets set parameters mnTS(). mTS() needs: row indices : sample_idx number covariates: p number state variables: n BOBO: B0.start.mnTS (intercept) BB: B.start.mnTS (driver-taxa) CC: C.start.mnTS (taxa interactions) VV: V.start.mnTS (cross-correlated error) BOBO: B0.fixed.mnTS BB: B.fixed.mnTS CC: C.fixed.mnTS VV: V.fixed.mnTS using output mnGLMM() starting values matrices B0B0, BB, VV. mnGLMM() provide estimates CC, handle CC little differently input values close zero parameter estimated let mnTS() rest. Remember, mnTS() handle gaps state-variables data covariate matrix. following code, use complete (gaps) YY matrix story_pollen_matrix[sample_idx, ] dimensions: r dim(story_pollen_matrix[sample_idx, ]). full XX matrix: story_char_matrix_scaled dimensions: r dim(story_char_matrix_scaled) fit model twice: - without taxa interactions - without taxa interactions. Without interactions interactions start_time <- Sys.time() mnTS_mod <- mnTS(Y = story_pollen_matrix[sample_idx, ],                  X = story_char_matrix_scaled, Tsample = sample_idx,                  B0.start = B0.start.mnTS, B0.fixed = B0.fixed.mnTS,                  B.start = B.start.mnTS, B.fixed = B.fixed.mnTS,                  C.start = C.start.mnTS, C.fixed = C.fixed.mnTS,                  V.start = V.start.mnTS, V.fixed = V.fixed.mnTS,                  dispersion.fixed = 1, maxit.optim = 1e+6) # maxit.optim max number iterations optimiser complete stopping. # increase maxit.optim model needs lot time fit. end_time <- Sys.time() end_time - start_time saveRDS(mnTS_mod, \"./outputs/mnTS_mod.rds\") coef() summary() functions show model outputs. Let’s check coefficients interaction model: found bootstrapping provides better estimates standard erros (subsequent P-values). boot() function bootstrap model, may take long time. won’t today, strongly recommend bootstrapping final models. summary model provides log likelihood AIC (akaike information criterion). can used comparing models. Today use AIC. AIC penalised number parameters estimated, can better comparing models one parameters estimated (.e., interaction model estimating parameters model without interactions). AIC (log likelihood) values can accessed directly mnTS_mod_int$AIC.","code":"# set-up sample index sample_idx <- which(rowSums(story_pollen_matrix) != 0) # make sure it works head(story_pollen_matrix[sample_idx, ]) # Set-up parameters p <- ncol(story_char_matrix_scaled) + 1 # Number of independent variables plus intercept n <- ncol(story_pollen_matrix) # number of taxa V.fixed.glmm <- diag(n) diag(V.fixed.glmm) <- NA V.fixed.glmm[1] <- 1 B.fixed.glmm <- matrix(c(rep(0,p),rep(NA, (n - 1) * p)), p, n) # reference taxa [,1] are set to 0 B.start.glmm <- matrix(c(rep(0,p),rep(.01, (n - 1) * p)), p, n) # reference taxa [,1] are set to 0 # fit glmm start_time <- Sys.time() glmm_mod <- mnGLMM(Y = story_pollen_matrix[sample_idx, ],                    X = story_char_matrix_scaled[sample_idx, ,drop = F],                    B.start = B.start.glmm,                    B.fixed = B.fixed.glmm,                    V.fixed = V.fixed.glmm) end_time <- Sys.time() end_time - start_time saveRDS(glmm_mod, \"./outputs/glmm_mod.rds\") glmm_mod <- readRDS(\"./outputs/glmm_mod.rds\") summary(glmm_mod) # B.start etc B0.start.mnTS <- glmm_mod$B[1, , drop = F] B.start.mnTS <- glmm_mod$B[2, , drop = F]  sigma.start.mnTS <- glmm_mod$sigma  V.fixed.mnTS = matrix(NA, n, n) # Covariance matrix of environmental variation in process eq V.fixed.mnTS[1] = 1  V.start.mnTS = V.fixed.mnTS V.start.mnTS <- glmm_mod$V  B.fixed.mnTS <- matrix(NA, p-1, n) B.fixed.mnTS[,1] <- 0 B0.fixed.mnTS = matrix(c(0, rep(NA, n - 1)), nrow = 1, ncol = n)  # Set-up C without interactions C.start.mnTS = .5 * diag(n) C.fixed.mnTS <- C.start.mnTS C.fixed.mnTS[C.fixed.mnTS != 0] <- NA  # Set-up C with interactions between Fagus and Quercus C.start.int.mnTS = .5 * diag(n) C.start.int.mnTS[5, 4] <- .001 C.start.int.mnTS[4, 5] <- .001 C.fixed.int.mnTS <- C.start.int.mnTS C.fixed.int.mnTS[C.fixed.int.mnTS != 0] <- NA start_time <- Sys.time() mnTS_mod <- mnTS(Y = story_pollen_matrix[sample_idx, ],                  X = story_char_matrix_scaled, Tsample = sample_idx,                  B0.start = B0.start.mnTS, B0.fixed = B0.fixed.mnTS,                  B.start = B.start.mnTS, B.fixed = B.fixed.mnTS,                  C.start = C.start.mnTS, C.fixed = C.fixed.mnTS,                  V.start = V.start.mnTS, V.fixed = V.fixed.mnTS,                  dispersion.fixed = 1, maxit.optim = 1e+6) # maxit.optim is the max number of iterations the optimiser will complete before stopping. # increase maxit.optim if the model needs a lot of time to fit. end_time <- Sys.time() end_time - start_time saveRDS(mnTS_mod, \"./outputs/mnTS_mod.rds\") start_time <- Sys.time() mnTS_mod_int <- mnTS(Y = story_pollen_matrix[sample_idx, ],                      X = story_char_matrix_scaled, Tsample = sample_idx,                      B0.start = mnTS_mod$B0, B0.fixed = B0.fixed.mnTS,                      B.start = mnTS_mod$B, B.fixed = B.fixed.mnTS,                      C.start = mnTS_mod$C, C.fixed = C.fixed.int.mnTS,                      V.start = mnTS_mod$V, V.fixed = V.fixed.mnTS,                      dispersion.fixed = 1, maxit.optim = 1e+6) end_time <- Sys.time()  end_time - start_time saveRDS(mnTS_mod_int, \"./outputs/mnTS_mod_int.rds\") mnTS_mod <- readRDS(\"./outputs/mnTS_mod.rds\") mnTS_mod_int <- readRDS(\"./outputs/mnTS_mod_int.rds\") coef(mnTS_mod_int) data.frame(without_interactions = mnTS_mod$AIC,            with_interactions = mnTS_mod_int$AIC)"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"finding-initial-conditions-using-mnglmm","dir":"Articles","previous_headings":"Fitting mnTS()","what":"Finding initial conditions using mnGLMM()","title":"multinomialTS Vignette","text":"mnTS() function provide estimates biotic interactions (CC matrix), taxa-driver relationships (BB matrix), cross-correlated error (VV matrix). model needs initial starting values parameters begin . get initial starting conditions data running mnGLMM() funcion. mnGLMM() returns estimates BB VV matrices (CC matrix) assumes time gaps data. Tip arguments starting values mnGLMM() mnTS() suffixed .start (e.g., B.start starting values BB matrix). arguments parameters estimated suffixed .fixed (e.g., B.fixed parameters estimated BB matrix). Now, lets set parameters mnGLMM(). need: vector indicates row indices state variable observations: sample_idx integer number covariates (+ 1 mnGLMM()): p integer number state variables: n matrix starting values BB: B.start.glmm matrix BB parameters estimate: B.fixed.glmm matrix VV parameters estimate: V.fixed.glmm Set-remaining parameters: parameters used arguments mnGLMM() function. Check printing console. matrix needs correct dimensions given number taxa number covariates. position elements matrix reflect species /covariates, see later output model. Remember mnGLMM() handle gaps data fits complete XX YY matrices. created variable observation indices (sample_idx), mnGLMM() index matrices variable: e.g., story_pollen_matrix[sample_idx, ]. outputs mnGLMM() can examined summary(glmm_mod) coef(glmm_mod) functions. Now, lets set parameters mnTS(). mTS() needs: row indices : sample_idx number covariates: p number state variables: n BOBO: B0.start.mnTS (intercept) BB: B.start.mnTS (driver-taxa) CC: C.start.mnTS (taxa interactions) VV: V.start.mnTS (cross-correlated error) BOBO: B0.fixed.mnTS BB: B.fixed.mnTS CC: C.fixed.mnTS VV: V.fixed.mnTS using output mnGLMM() starting values matrices B0B0, BB, VV. mnGLMM() provide estimates CC, handle CC little differently input values close zero parameter estimated let mnTS() rest. Remember, mnTS() handle gaps state-variables data covariate matrix. following code, use complete (gaps) YY matrix story_pollen_matrix[sample_idx, ] dimensions: r dim(story_pollen_matrix[sample_idx, ]). full XX matrix: story_char_matrix_scaled dimensions: r dim(story_char_matrix_scaled) fit model twice: - without taxa interactions - without taxa interactions. Without interactions interactions start_time <- Sys.time() mnTS_mod <- mnTS(Y = story_pollen_matrix[sample_idx, ],                  X = story_char_matrix_scaled, Tsample = sample_idx,                  B0.start = B0.start.mnTS, B0.fixed = B0.fixed.mnTS,                  B.start = B.start.mnTS, B.fixed = B.fixed.mnTS,                  C.start = C.start.mnTS, C.fixed = C.fixed.mnTS,                  V.start = V.start.mnTS, V.fixed = V.fixed.mnTS,                  dispersion.fixed = 1, maxit.optim = 1e+6) # maxit.optim max number iterations optimiser complete stopping. # increase maxit.optim model needs lot time fit. end_time <- Sys.time() end_time - start_time saveRDS(mnTS_mod, \"./outputs/mnTS_mod.rds\")","code":"# set-up sample index sample_idx <- which(rowSums(story_pollen_matrix) != 0) # make sure it works head(story_pollen_matrix[sample_idx, ]) # Set-up parameters p <- ncol(story_char_matrix_scaled) + 1 # Number of independent variables plus intercept n <- ncol(story_pollen_matrix) # number of taxa V.fixed.glmm <- diag(n) diag(V.fixed.glmm) <- NA V.fixed.glmm[1] <- 1 B.fixed.glmm <- matrix(c(rep(0,p),rep(NA, (n - 1) * p)), p, n) # reference taxa [,1] are set to 0 B.start.glmm <- matrix(c(rep(0,p),rep(.01, (n - 1) * p)), p, n) # reference taxa [,1] are set to 0 # fit glmm start_time <- Sys.time() glmm_mod <- mnGLMM(Y = story_pollen_matrix[sample_idx, ],                    X = story_char_matrix_scaled[sample_idx, ,drop = F],                    B.start = B.start.glmm,                    B.fixed = B.fixed.glmm,                    V.fixed = V.fixed.glmm) end_time <- Sys.time() end_time - start_time saveRDS(glmm_mod, \"./outputs/glmm_mod.rds\") glmm_mod <- readRDS(\"./outputs/glmm_mod.rds\") summary(glmm_mod) # B.start etc B0.start.mnTS <- glmm_mod$B[1, , drop = F] B.start.mnTS <- glmm_mod$B[2, , drop = F]  sigma.start.mnTS <- glmm_mod$sigma  V.fixed.mnTS = matrix(NA, n, n) # Covariance matrix of environmental variation in process eq V.fixed.mnTS[1] = 1  V.start.mnTS = V.fixed.mnTS V.start.mnTS <- glmm_mod$V  B.fixed.mnTS <- matrix(NA, p-1, n) B.fixed.mnTS[,1] <- 0 B0.fixed.mnTS = matrix(c(0, rep(NA, n - 1)), nrow = 1, ncol = n)  # Set-up C without interactions C.start.mnTS = .5 * diag(n) C.fixed.mnTS <- C.start.mnTS C.fixed.mnTS[C.fixed.mnTS != 0] <- NA  # Set-up C with interactions between Fagus and Quercus C.start.int.mnTS = .5 * diag(n) C.start.int.mnTS[5, 4] <- .001 C.start.int.mnTS[4, 5] <- .001 C.fixed.int.mnTS <- C.start.int.mnTS C.fixed.int.mnTS[C.fixed.int.mnTS != 0] <- NA start_time <- Sys.time() mnTS_mod <- mnTS(Y = story_pollen_matrix[sample_idx, ],                  X = story_char_matrix_scaled, Tsample = sample_idx,                  B0.start = B0.start.mnTS, B0.fixed = B0.fixed.mnTS,                  B.start = B.start.mnTS, B.fixed = B.fixed.mnTS,                  C.start = C.start.mnTS, C.fixed = C.fixed.mnTS,                  V.start = V.start.mnTS, V.fixed = V.fixed.mnTS,                  dispersion.fixed = 1, maxit.optim = 1e+6) # maxit.optim is the max number of iterations the optimiser will complete before stopping. # increase maxit.optim if the model needs a lot of time to fit. end_time <- Sys.time() end_time - start_time saveRDS(mnTS_mod, \"./outputs/mnTS_mod.rds\") start_time <- Sys.time() mnTS_mod_int <- mnTS(Y = story_pollen_matrix[sample_idx, ],                      X = story_char_matrix_scaled, Tsample = sample_idx,                      B0.start = mnTS_mod$B0, B0.fixed = B0.fixed.mnTS,                      B.start = mnTS_mod$B, B.fixed = B.fixed.mnTS,                      C.start = mnTS_mod$C, C.fixed = C.fixed.int.mnTS,                      V.start = mnTS_mod$V, V.fixed = V.fixed.mnTS,                      dispersion.fixed = 1, maxit.optim = 1e+6) end_time <- Sys.time()  end_time - start_time saveRDS(mnTS_mod_int, \"./outputs/mnTS_mod_int.rds\") mnTS_mod <- readRDS(\"./outputs/mnTS_mod.rds\") mnTS_mod_int <- readRDS(\"./outputs/mnTS_mod_int.rds\")"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"setting-up-parameters-for-mngmll","dir":"Articles","previous_headings":"Fitting mnTS()","what":"Setting-up parameters for mnGMLL()","title":"multinomialTS Vignette","text":"Now, lets set parameters mnGLMM(). need: vector indicates row indices state variable observations: sample_idx integer number covariates (+ 1 mnGLMM()): p integer number state variables: n matrix starting values BB: B.start.glmm matrix BB parameters estimate: B.fixed.glmm matrix VV parameters estimate: V.fixed.glmm Set-remaining parameters: parameters used arguments mnGLMM() function. Check printing console. matrix needs correct dimensions given number taxa number covariates. position elements matrix reflect species /covariates, see later output model.","code":"# set-up sample index sample_idx <- which(rowSums(story_pollen_matrix) != 0) # make sure it works head(story_pollen_matrix[sample_idx, ]) # Set-up parameters p <- ncol(story_char_matrix_scaled) + 1 # Number of independent variables plus intercept n <- ncol(story_pollen_matrix) # number of taxa V.fixed.glmm <- diag(n) diag(V.fixed.glmm) <- NA V.fixed.glmm[1] <- 1 B.fixed.glmm <- matrix(c(rep(0,p),rep(NA, (n - 1) * p)), p, n) # reference taxa [,1] are set to 0 B.start.glmm <- matrix(c(rep(0,p),rep(.01, (n - 1) * p)), p, n) # reference taxa [,1] are set to 0"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"fitting-mnglmm","dir":"Articles","previous_headings":"Fitting mnTS()","what":"Fitting mnGLMM()","title":"multinomialTS Vignette","text":"Remember mnGLMM() handle gaps data fits complete XX YY matrices. created variable observation indices (sample_idx), mnGLMM() index matrices variable: e.g., story_pollen_matrix[sample_idx, ]. outputs mnGLMM() can examined summary(glmm_mod) coef(glmm_mod) functions.","code":"# fit glmm start_time <- Sys.time() glmm_mod <- mnGLMM(Y = story_pollen_matrix[sample_idx, ],                    X = story_char_matrix_scaled[sample_idx, ,drop = F],                    B.start = B.start.glmm,                    B.fixed = B.fixed.glmm,                    V.fixed = V.fixed.glmm) end_time <- Sys.time() end_time - start_time saveRDS(glmm_mod, \"./outputs/glmm_mod.rds\") glmm_mod <- readRDS(\"./outputs/glmm_mod.rds\") summary(glmm_mod)"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"setting-up-parameters-for-mnts","dir":"Articles","previous_headings":"Fitting mnTS()","what":"Setting-up parameters for mnTS()","title":"multinomialTS Vignette","text":"Now, lets set parameters mnTS(). mTS() needs: row indices : sample_idx number covariates: p number state variables: n BOBO: B0.start.mnTS (intercept) BB: B.start.mnTS (driver-taxa) CC: C.start.mnTS (taxa interactions) VV: V.start.mnTS (cross-correlated error) BOBO: B0.fixed.mnTS BB: B.fixed.mnTS CC: C.fixed.mnTS VV: V.fixed.mnTS using output mnGLMM() starting values matrices B0B0, BB, VV. mnGLMM() provide estimates CC, handle CC little differently input values close zero parameter estimated let mnTS() rest.","code":"# B.start etc B0.start.mnTS <- glmm_mod$B[1, , drop = F] B.start.mnTS <- glmm_mod$B[2, , drop = F]  sigma.start.mnTS <- glmm_mod$sigma  V.fixed.mnTS = matrix(NA, n, n) # Covariance matrix of environmental variation in process eq V.fixed.mnTS[1] = 1  V.start.mnTS = V.fixed.mnTS V.start.mnTS <- glmm_mod$V  B.fixed.mnTS <- matrix(NA, p-1, n) B.fixed.mnTS[,1] <- 0 B0.fixed.mnTS = matrix(c(0, rep(NA, n - 1)), nrow = 1, ncol = n)  # Set-up C without interactions C.start.mnTS = .5 * diag(n) C.fixed.mnTS <- C.start.mnTS C.fixed.mnTS[C.fixed.mnTS != 0] <- NA  # Set-up C with interactions between Fagus and Quercus C.start.int.mnTS = .5 * diag(n) C.start.int.mnTS[5, 4] <- .001 C.start.int.mnTS[4, 5] <- .001 C.fixed.int.mnTS <- C.start.int.mnTS C.fixed.int.mnTS[C.fixed.int.mnTS != 0] <- NA"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"fitting-mnts-1","dir":"Articles","previous_headings":"Fitting mnTS()","what":"Fitting mnTS()","title":"multinomialTS Vignette","text":"Remember, mnTS() handle gaps state-variables data covariate matrix. following code, use complete (gaps) YY matrix story_pollen_matrix[sample_idx, ] dimensions: r dim(story_pollen_matrix[sample_idx, ]). full XX matrix: story_char_matrix_scaled dimensions: r dim(story_char_matrix_scaled) fit model twice: - without taxa interactions - without taxa interactions. Without interactions interactions start_time <- Sys.time() mnTS_mod <- mnTS(Y = story_pollen_matrix[sample_idx, ],                  X = story_char_matrix_scaled, Tsample = sample_idx,                  B0.start = B0.start.mnTS, B0.fixed = B0.fixed.mnTS,                  B.start = B.start.mnTS, B.fixed = B.fixed.mnTS,                  C.start = C.start.mnTS, C.fixed = C.fixed.mnTS,                  V.start = V.start.mnTS, V.fixed = V.fixed.mnTS,                  dispersion.fixed = 1, maxit.optim = 1e+6) # maxit.optim max number iterations optimiser complete stopping. # increase maxit.optim model needs lot time fit. end_time <- Sys.time() end_time - start_time saveRDS(mnTS_mod, \"./outputs/mnTS_mod.rds\")","code":"start_time <- Sys.time() mnTS_mod <- mnTS(Y = story_pollen_matrix[sample_idx, ],                  X = story_char_matrix_scaled, Tsample = sample_idx,                  B0.start = B0.start.mnTS, B0.fixed = B0.fixed.mnTS,                  B.start = B.start.mnTS, B.fixed = B.fixed.mnTS,                  C.start = C.start.mnTS, C.fixed = C.fixed.mnTS,                  V.start = V.start.mnTS, V.fixed = V.fixed.mnTS,                  dispersion.fixed = 1, maxit.optim = 1e+6) # maxit.optim is the max number of iterations the optimiser will complete before stopping. # increase maxit.optim if the model needs a lot of time to fit. end_time <- Sys.time() end_time - start_time saveRDS(mnTS_mod, \"./outputs/mnTS_mod.rds\") start_time <- Sys.time() mnTS_mod_int <- mnTS(Y = story_pollen_matrix[sample_idx, ],                      X = story_char_matrix_scaled, Tsample = sample_idx,                      B0.start = mnTS_mod$B0, B0.fixed = B0.fixed.mnTS,                      B.start = mnTS_mod$B, B.fixed = B.fixed.mnTS,                      C.start = mnTS_mod$C, C.fixed = C.fixed.int.mnTS,                      V.start = mnTS_mod$V, V.fixed = V.fixed.mnTS,                      dispersion.fixed = 1, maxit.optim = 1e+6) end_time <- Sys.time()  end_time - start_time saveRDS(mnTS_mod_int, \"./outputs/mnTS_mod_int.rds\") mnTS_mod <- readRDS(\"./outputs/mnTS_mod.rds\") mnTS_mod_int <- readRDS(\"./outputs/mnTS_mod_int.rds\")"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"interpreting-outputs","dir":"Articles","previous_headings":"Fitting mnTS()","what":"Interpreting outputs","title":"multinomialTS Vignette","text":"coef() summary() functions show model outputs. Let’s check coefficients interaction model: found bootstrapping provides better estimates standard erros (subsequent P-values). boot() function bootstrap model, may take long time. won’t today, strongly recommend bootstrapping final models.","code":"coef(mnTS_mod_int)"},{"path":"https://quinnasena.github.io/multinomialTS/articles/multinomialTS-vignette.html","id":"comparing-models","dir":"Articles","previous_headings":"Fitting mnTS()","what":"Comparing models","title":"multinomialTS Vignette","text":"summary model provides log likelihood AIC (akaike information criterion). can used comparing models. Today use AIC. AIC penalised number parameters estimated, can better comparing models one parameters estimated (.e., interaction model estimating parameters model without interactions). AIC (log likelihood) values can accessed directly mnTS_mod_int$AIC.","code":"data.frame(without_interactions = mnTS_mod$AIC,            with_interactions = mnTS_mod_int$AIC)"},{"path":"https://quinnasena.github.io/multinomialTS/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Quinn Asena. Maintainer.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ives , Asena Q (2025). multinomialTS: State-Space Modelling Multinomially Distributed Data. R package version 1.0.0, https://quinnasena.github.io/multinomialTS/.","code":"@Manual{,   title = {multinomialTS: State-Space Modelling of Multinomially Distributed Data},   author = {Anthony Ives and Quinn Asena},   year = {2025},   note = {R package version 1.0.0},   url = {https://quinnasena.github.io/multinomialTS/}, }"},{"path":"https://quinnasena.github.io/multinomialTS/index.html","id":"multinomialts","dir":"","previous_headings":"","what":"State-Space Modelling of Multinomially Distributed Data","title":"State-Space Modelling of Multinomially Distributed Data","text":"initial working version multinomialTS. full working tutorial using model, including installation instructions, can found : https://github.com/QuinnAsena/state-space-workhop-ESA.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/boot.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial state-space bootstrap — boot","title":"Multinomial state-space bootstrap — boot","text":"generic bootstrap function models.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/boot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial state-space bootstrap — boot","text":"","code":"boot(object, ...)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/boot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multinomial state-space bootstrap — boot","text":"object object bootstrap method defined. ... Additional arguments passed method.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/boot.mnTS.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap method for mnTS objects — boot.mnTS","title":"Bootstrap method for mnTS objects — boot.mnTS","text":"Provides bootstrapped confidence intervals object class mnTS.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/boot.mnTS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap method for mnTS objects — boot.mnTS","text":"","code":"# S3 method for class 'mnTS' boot(mod, reps, dispersion.fixed = 1, maxit.optim = 1e+05, ...)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/boot.mnTS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap method for mnTS objects — boot.mnTS","text":"reps Integer. Number bootstrap replications. dispersion.fixed Numeric. Dispersion parameter (default 1). maxit.optim Integer. Max iterations optimization (default 100000). ... Additional arguments (currently used). object object class mnTS.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/coef.mnTS.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients for Multinomial State-Space Model — coef.mnTS","title":"Coefficients for Multinomial State-Space Model — coef.mnTS","text":"Extracts estimated coefficients fitted multinomial state-space model.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/coef.mnTS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients for Multinomial State-Space Model — coef.mnTS","text":"","code":"# S3 method for class 'mnTS' coef(mod, ...)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/coef.mnTS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients for Multinomial State-Space Model — coef.mnTS","text":"mod object class \"mnTS\", returned mnTS function. ... Additional arguments (currently unused).","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/coef.mnTS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients for Multinomial State-Space Model — coef.mnTS","text":"list estimated model coefficients.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnGLMM.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial Generalized Linear Mixed Model (mnGLMM) — mnGLMM","title":"Multinomial Generalized Linear Mixed Model (mnGLMM) — mnGLMM","text":"Fits multivariate generalized linear regression model multinomially distributed response data. function estimates driver-species relationships (B coefficients), observation-level dispersion, species covariance structures via maximum likelihood REML.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnGLMM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial Generalized Linear Mixed Model (mnGLMM) — mnGLMM","text":"","code":"mnGLMM(   Y,   X = NULL,   B.fixed = if (is.null(X)) matrix(c(0, rep(NA, ncol(Y) - 1)), nrow = 1, ncol = ncol(Y))     else matrix(c(rep(0, (ncol(X) + 1) * ncol(Y)), rep(NA, (ncol(Y) - 1) * (ncol(X) +     1))), nrow = ncol(X) + 1, ncol = ncol(Y)),   B.start = if (is.null(X)) matrix(0, nrow = 1, ncol = ncol(Y)) else matrix(0, nrow =     ncol(X) + 1, ncol = ncol(Y)),   sigma.fixed = NA,   sigma.start = 0.1,   dispersion.fixed = 1,   dispersion.start = 1,   V.fixed = diag(ncol(Y)),   V.start = diag(ncol(Y)),   method = \"bobyqa\",   optim.control = NULL,   maxit.optim = 1e+05,   REML = FALSE,   compute.information.matrix = TRUE )"},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnGLMM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multinomial Generalized Linear Mixed Model (mnGLMM) — mnGLMM","text":"Y matrix multinomially distributed count data (e.g., community count data). X matrix covariates (predictors), may mixed type Covariates scaled appropriate. Can NULL. B.fixed matrix indicating B coefficients (driver-species relationships) estimate. number columns must equal ncol(Y) (number species), number rows must equal ncol(X) + 1 (intercept + covariates). B.start matrix starting values B coefficients. Dimensions must match B.fixed. sigma.fixed Fixed value overall model variance. Use NA estimate model. sigma.start Starting value estimating sigma.fixed (default 0.1). dispersion.fixed Fixed dispersion parameter account - -dispersion. value 1 corresponds extra dispersion (pure multinomial). dispersion.start Starting value estimating dispersion.fixed. V.fixed species--species covariance matrix representing environmental variation. V.start Starting values V.fixed. method Optimization method. Acceptable values include \"Nelder-Mead\", \"BFGS\" (via optim), \"bobyqa\" (via minqa package). optim.control Optional list control parameters passed optimizer. See minqa package documentation details. maxit.optim Maximum number iterations optimizer (default 1e+05). Increase optimizer needs itterations. REML Logical. TRUE, uses restricted maximum likelihood variance estimation. compute.information.matrix Logical. TRUE, computes observed information matrix.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnGLMM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multinomial Generalized Linear Mixed Model (mnGLMM) — mnGLMM","text":"object class \"mnGLMM\".","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnGLMM.ml.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial GLMM Maximum likelihood — mnGLMM.ml","title":"Multinomial GLMM Maximum likelihood — mnGLMM.ml","text":"internal function called mnGLMM.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnGLMM.ml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial GLMM Maximum likelihood — mnGLMM.ml","text":"","code":"mnGLMM.ml(par, par.fixed, Y, X, fitted.values = FALSE, REML = FALSE)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial State-Space Model (mnTS) — mnTS","title":"Multinomial State-Space Model (mnTS) — mnTS","text":"Fits multinomial state-space model multivariate count data, allowing latent temporal processes, covariate effects, species interactions.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial State-Space Model (mnTS) — mnTS","text":"","code":"mnTS(   Y,   X = NULL,   Tsample = 1:nrow(Y),   B0.fixed = matrix(c(0, rep(NA, ncol(Y) - 1)), nrow = 1, ncol = ncol(Y)),   B0.start = matrix(0, nrow = 1, ncol = ncol(Y)),   C.fixed = diag(rep(NA, ncol(Y))),   C.start = 0.01 * diag(ncol(Y)),   B.fixed = if (is.null(X)) NULL else matrix(NA, nrow = ncol(X), ncol = ncol(Y)),   B.start = if (is.null(X)) NULL else matrix(0, nrow = ncol(X), ncol = ncol(Y)),   sigma.fixed = NA,   sigma.start = 0.1,   dispersion.fixed = 1,   dispersion.start = 1,   V.fixed = diag(ncol(Y)),   V.start = diag(ncol(Y)),   compute.information.matrix = TRUE,   method = \"bobyqa\",   optim.control = NULL,   maxit.optim = 1e+05,   hessian.method.args = list(eps = 1e-04, d = 1e-04, r = 4, v = 2) )"},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multinomial State-Space Model (mnTS) — mnTS","text":"Y matrix multinomially distributed count data (e.g., community count data). X matrix covariates (predictors), may mixed type. Covariates scaled appropriate. Can NULL. Tsample vector row indices specifying subset observations Y treat temporal samples. B0.fixed 1 ncol(Y) matrix species intercepts estimate. B0.start matrix starting values B0.fixed. C.fixed species--species matrix interactions, indicating interactions estimate. C.start matrix starting values C.fixed. B.fixed matrix indicating B coefficients (driver-species relationships) estimate. ncol(Y) columns ncol(X) rows. B.start matrix starting values B.fixed. Dimensions B.start match B.fixed. sigma.fixed Fixed value overall model variance. Use NA estimate model. sigma.start Starting value estimating sigma.fixed. dispersion.fixed Fixed dispersion parameter observation-level variation. value 1 corresponds - -dispersion. dispersion.start Starting value estimating dispersion.fixed. V.fixed species--species covariance matrix representing environmental variation. V.start Starting values V.fixed. compute.information.matrix Logical. TRUE, computes observed information matrix. method Optimization method. Acceptable values include \"Nelder-Mead\", \"BFGS\" (via optim), \"bobyqa\" (via minqa package). optim.control Optional list control parameters passed optimizer. See minqa package documentation details. maxit.optim Maximum number iterations optimizer (default 1e+05). Increase optimizer needs iterations. hessian.method.args list control parameters passed numerical Hessian calculator (e.g., numDeriv::hessian).","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multinomial State-Space Model (mnTS) — mnTS","text":"object class \"mnTS\" containing estimated parameters.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS.ml.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial state-space Maximum likelihood — mnTS.ml","title":"Multinomial state-space Maximum likelihood — mnTS.ml","text":"internal function called mnTS","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS.ml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial state-space Maximum likelihood — mnTS.ml","text":"","code":"mnTS.ml(par, par.fixed, Y, X = NULL, Tsample, fitted.values = FALSE)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS.ml.wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"mnTS Wrapper — mnTS.ml.wrapper","title":"mnTS Wrapper — mnTS.ml.wrapper","text":"internal functions required multinomialTS.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS.ml.wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mnTS Wrapper — mnTS.ml.wrapper","text":"","code":"mnTS.ml.wrapper(par, par.fixed, Y, X, Tsample)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS_ml_cpp_listout.html","id":null,"dir":"Reference","previous_headings":"","what":"mnTS_ml_cpp_list — mnTS_ml_cpp_listout","title":"mnTS_ml_cpp_list — mnTS_ml_cpp_listout","text":"internal functions required multinomialTS.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/mnTS_ml_cpp_listout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mnTS_ml_cpp_list — mnTS_ml_cpp_listout","text":"","code":"mnTS_ml_cpp_listout(par, par_fixed, Y, X, Tsample)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/simulate.mnTS.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Data from a Multinomial State-Space Model — simulate.mnTS","title":"Simulate Data from a Multinomial State-Space Model — simulate.mnTS","text":"Generates simulated datasets fitted mnTS object.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/simulate.mnTS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Data from a Multinomial State-Space Model — simulate.mnTS","text":"","code":"# S3 method for class 'mnTS' simulate(mod, ...)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/simulate.mnTS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Data from a Multinomial State-Space Model — simulate.mnTS","text":"mod object class \"mnTS\", returned mnTS function. ... Additional arguments passed simulation routine.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/simulate.mnTS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Data from a Multinomial State-Space Model — simulate.mnTS","text":"simulated dataset structure response variable     Y used fit model.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Story Charcoal Matrix — story_char_matrix","title":"Story Charcoal Matrix — story_char_matrix","text":"matrix charcoal accumulation rates Story Lake, Indiana.    matrix binned 50-year resolution scaled.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Story Charcoal Matrix — story_char_matrix","text":"","code":"story_char_matrix"},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_matrix.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Story Charcoal Matrix — story_char_matrix","text":"`1` column matrix `160` rows (observations).","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_matrix.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Story Charcoal Matrix — story_char_matrix","text":"details see vignette","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Story Charcoal Matrix — story_char_matrix","text":"","code":"data(story_char_matrix) #> Warning: data set ‘story_char_matrix’ not found head(story_char_matrix) #> Error: object 'story_char_matrix' not found"},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_wide.html","id":null,"dir":"Reference","previous_headings":"","what":"Story Charcoal Wide — story_char_wide","title":"Story Charcoal Wide — story_char_wide","text":"~10,000-year data set Story Lake, Indiana, modelled ages, sample    depths, charcoal accumulation rate sediment core sample.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_wide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Story Charcoal Wide — story_char_wide","text":"","code":"story_char_wide"},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_wide.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Story Charcoal Wide — story_char_wide","text":"tibble `736` rows `3` columns.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_wide.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Story Charcoal Wide — story_char_wide","text":"details see https://doi.org/10.1111/1365-2745.14289","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_char_wide.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Story Charcoal Wide — story_char_wide","text":"","code":"data(story_char_wide) #> Warning: data set ‘story_char_wide’ not found str(story_char_wide) #> Error: object 'story_char_wide' not found"},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Story Pollen Matrix — story_pollen_matrix","title":"Story Pollen Matrix — story_pollen_matrix","text":"matrix pollen taxa counts Story Lake, Indiana. Data organised    reference group \"\" taxa, functional group hardwood    taxa, target taxa Fagus grandifolia, Ulmus spp., Quercus spp.    Data binned 50-year resolution empty bins filled    0-values (.e., rows 0 empty bins, see vignette details).","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Story Pollen Matrix — story_pollen_matrix","text":"","code":"story_pollen_matrix"},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_matrix.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Story Pollen Matrix — story_pollen_matrix","text":"matrix `160` rows (samples) `5` columns (taxa).","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_matrix.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Story Pollen Matrix — story_pollen_matrix","text":"details see vignette","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Story Pollen Matrix — story_pollen_matrix","text":"","code":"data(story_pollen_matrix) #> Warning: data set ‘story_pollen_matrix’ not found summary(story_pollen_matrix) #> Error: object 'story_pollen_matrix' not found"},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_wide.html","id":null,"dir":"Reference","previous_headings":"","what":"Story Pollen Wide — story_pollen_wide","title":"Story Pollen Wide — story_pollen_wide","text":"~10,000-year data set Story Lake, Indiana, modelled ages, sample    depths, pollen taxa. Data organised reference group    \"\" taxa, functional group hardwood taxa, target taxa    Fagus grandifolia, Ulmus spp., Quercus spp.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_wide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Story Pollen Wide — story_pollen_wide","text":"","code":"story_pollen_wide"},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_wide.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Story Pollen Wide — story_pollen_wide","text":"tibble `95` rows (observations) `7` columns.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_wide.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Story Pollen Wide — story_pollen_wide","text":"details see https://doi.org/10.1111/1365-2745.14289","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/story_pollen_wide.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Story Pollen Wide — story_pollen_wide","text":"","code":"data(story_pollen_wide) #> Warning: data set ‘story_pollen_wide’ not found names(story_pollen_wide) #> Error: object 'story_pollen_wide' not found"},{"path":"https://quinnasena.github.io/multinomialTS/reference/summary.mnGLMM.html","id":null,"dir":"Reference","previous_headings":"","what":"GLMM summary — summary.mnGLMM","title":"GLMM summary — summary.mnGLMM","text":"Prints summary mnGLMM model.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/summary.mnGLMM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GLMM summary — summary.mnGLMM","text":"","code":"# S3 method for class 'mnGLMM' summary(mod, ...)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/summary.mnGLMM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GLMM summary — summary.mnGLMM","text":"mod object class \"mnGLMM\"","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/summary.mnGLMM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GLMM summary — summary.mnGLMM","text":"Prints coefficient estimates fitted mnGLMM","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/summary.mnTS.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for Multinomial State-Space Models — summary.mnTS","title":"Summary Method for Multinomial State-Space Models — summary.mnTS","text":"Provides summary fitted multinomial state-space model.","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/summary.mnTS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for Multinomial State-Space Models — summary.mnTS","text":"","code":"# S3 method for class 'mnTS' summary(mod, ...)"},{"path":"https://quinnasena.github.io/multinomialTS/reference/summary.mnTS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for Multinomial State-Space Models — summary.mnTS","text":"mod object class \"mnTS\", typically returned mnTS function. ... Additional arguments (currently unused).","code":""},{"path":"https://quinnasena.github.io/multinomialTS/reference/summary.mnTS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary Method for Multinomial State-Space Models — summary.mnTS","text":"Returns summary list containing key model estimates.     Also prints summary console.","code":""}]
